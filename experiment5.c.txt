#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Environment signal
int trueSignal() {
    return (rand() % 2 == 0) ? 10 : -10;
}

// Perception with bias
int perceive(int signal, float bias) {
    int noise = (rand() % 5) - 2; // [-2..+2]
    return (int)(signal + bias + noise);
}

// Learning rule
void updateBias(float *bias, int outcome) {
    float lr = 0.05;

    if(outcome > 0)
        *bias += lr * 5;
    else
        *bias -= lr * 5;

    if(*bias > 20) *bias = 20;
    if(*bias < -20) *bias = -20;
}

// Observer stabilization
void observerCorrection(float *bias) {
    float rate = 0.02;

    if(*bias > 8)
        *bias -= rate * (*bias);
    else if(*bias < -8)
        *bias += rate * (-(*bias));
}

// One episode of interaction
void interactionStep(
    float *biasA, float *biasB,
    int *energyA, int *energyB,
    int observerOn)
{
    int signal = trueSignal();

    int pA = perceive(signal, *biasA);
    int pB = perceive(signal, *biasB);

    int actionA = (pA > 0) ? 1 : 0; // 1 = approach, 0 = avoid
    int actionB = (pB > 0) ? 1 : 0;

    int outcomeA = 0;
    int outcomeB = 0;

    // Social rule:
    // If both approach → competition (split reward or loss)
    // If one approaches → solo takes full outcome
    // If both avoid → both lose small energy

    if(actionA && actionB) {
        int shared = signal / 2;
        *energyA += shared;
        *energyB += shared;
        outcomeA = shared;
        outcomeB = shared;
    }
    else if(actionA && !actionB) {
        *energyA += signal;
        *energyB -= 1; // jealousy / missed opportunity
        outcomeA = signal;
        outcomeB = -1;
    }
    else if(!actionA && actionB) {
        *energyB += signal;
        *energyA -= 1;
        outcomeB = signal;
        outcomeA = -1;
    }
    else {
        *energyA -= 2;
        *energyB -= 2;
        outcomeA = -2;
        outcomeB = -2;
    }

    // Learning
    updateBias(biasA, outcomeA);
    updateBias(biasB, outcomeB);

    // Observer layer
    if(observerOn) {
        observerCorrection(biasA);
        observerCorrection(biasB);
    }
}

// Run simulation
void runSimulation(int steps, int observerOn,
                   int *finalA, int *finalB)
{
    float biasA = 0.0;
    float biasB = 0.0;
    int energyA = 50;
    int energyB = 50;

    for(int i = 0; i < steps; i++) {
        interactionStep(&biasA, &biasB,
                         &energyA, &energyB,
                         observerOn);
    }

    *finalA = energyA;
    *finalB = energyB;
}

// Average runs
void averageRun(int trials, int observerOn,
                float *avgA, float *avgB)
{
    int sumA = 0, sumB = 0;

    for(int i = 0; i < trials; i++) {
        int a, b;
        runSimulation(800, observerOn, &a, &b);
        sumA += a;
        sumB += b;
    }

    *avgA = (float)sumA / trials;
    *avgB = (float)sumB / trials;
}

int main() {
    srand(time(NULL));

    float A1, B1;
    float A2, B2;

    // Without observer
    averageRun(40, 0, &A1, &B1);

    // With observer
    averageRun(40, 1, &A2, &B2);

    printf("WITHOUT OBSERVER:\n");
    printf("Agent A Avg Energy: %.2f\n", A1);
    printf("Agent B Avg Energy: %.2f\n\n", B1);

    printf("WITH OBSERVER:\n");
    printf("Agent A Avg Energy: %.2f\n", A2);
    printf("Agent B Avg Energy: %.2f\n", B2);

    return 0;
}